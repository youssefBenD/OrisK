/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package tn.orisk.security.business;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.NamingException;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaQuery;
import javax.security.auth.login.LoginException;
import tn.orisk.Agent;
import tn.orisk.Authentification;
import tn.orisk.Filiale;

public final class DemoAuthenticator {

    private EntityManager em;
    private static DemoAuthenticator authenticator = null;
    // A user storage which stores <username, password>
    private final Map<String, String> usersStorage = new HashMap();
    // A service key storage which stores <service_key, username>
    private final Map<String, String> serviceKeysStorage = new HashMap();
    // An authentication token storage which stores <service_key, auth_token>.
    private final Map<String, String> authorizationTokensStorage = new HashMap();

    private DemoAuthenticator() {
        // The usersStorage pretty much represents a user table in the database
        usersStorage.put("username1", "passwordForUser1");
        usersStorage.put("username2", "passwordForUser2");
        usersStorage.put("username3", "passwordForUser3");

        /**
         * Service keys are pre-generated by the system and is given to the
         * authorized client who wants to have access to the REST API. Here,
         * only username1 and username2 is given the REST service access with
         * their respective service keys.
         */
        serviceKeysStorage.put("f80ebc87-ad5c-4b29-9366-5359768df5a1", "username1");
        serviceKeysStorage.put("3b91cab8-926f-49b6-ba00-920bcf934c2a", "username2");
    }

    public static DemoAuthenticator getInstance() {
        if (authenticator == null) {
            authenticator = new DemoAuthenticator();
        }

        return authenticator;
    }

    protected EntityManager getEntityManager() throws NamingException {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("0riskPU");
        return emf.createEntityManager();
    }

    public String login(String serviceKey, String username, String password) throws LoginException {
        if (serviceKeysStorage.containsKey(serviceKey)) {

            CriteriaQuery cq;
            List<Filiale> filiales = null;
            List<Agent> agents = null;
            try {
                cq = getEntityManager().getCriteriaBuilder().createQuery();
                cq.select(cq.from(Filiale.class));
                filiales = getEntityManager().createQuery(cq).getResultList();
                cq.select(cq.from(Agent.class));
                agents = getEntityManager().createQuery(cq).getResultList();


            } catch (NamingException ex) {
                Logger.getLogger(DemoAuthenticator.class.getName()).log(Level.SEVERE, null, ex);
            }
            Boolean trouveA = false;
            Boolean trouveF = false;
            Filiale filiale = null;
            Agent agent = null;
            for (int i = 0; i < filiales.size(); i++) {
                if (((Filiale) (filiales.get(i))).getEmail().equals(username)) {
                    filiale = (Filiale) filiales.get(i);
                    trouveF = true;
                    break;
                }
            }
            if (!trouveF) {
                for (int i = 0; i < agents.size(); i++) {
                    if (((Agent) (agents.get(i))).getEmail().equals(username)) {
                        agent = (Agent) agents.get(i);
                        System.out.println(agent.toString());
                        trouveA = true;
                        break;
                    }
                }
            }

            if (trouveF) {
                Query q;
                String result= "";
                try {
                    q = getEntityManager().createNativeQuery("SELECT p.relname FROM filiale f, pg_class p WHERE f.tableoid = p.oid AND f.filiale_id ='"+filiale.getFilialeId()+"'");
                    result = (String) q.getSingleResult();
                    System.out.println("*********" + result);
                } catch (NamingException ex) {
                    Logger.getLogger(DemoAuthenticator.class.getName()).log(Level.SEVERE, null, ex);
                }


                if (filiale.getPassword().equals(password)) {
                    String authToken = UUID.randomUUID().toString();
                    authorizationTokensStorage.put(authToken, username);
                    try {
                        Authentification a = new Authentification(filiale.getFilialeId(), result, authToken);
                        this.getEntityManager().persist(a);
                    } catch (NamingException ex) {
                        Logger.getLogger(DemoAuthenticator.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    return filiale.getFilialeId() + "/" + authToken + "/"+result;
                }
            } else {
                if (trouveA) {
                    if (agent.getPassword().equals(password)) {
                        String authToken = UUID.randomUUID().toString();
                        authorizationTokensStorage.put(authToken, username);
                        try {
                            Authentification a = new Authentification(agent.getAgentId(), "agent", authToken);
                            this.getEntityManager().persist(a);
                        } catch (NamingException ex) {
                            Logger.getLogger(DemoAuthenticator.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        return agent.getAgentId() + "/" + authToken + "/agent";
                    }
                }
            }
        }
        throw new LoginException("Don't Come Here Again!");
    }

    /**
     * The method that pre-validates if the client which invokes the REST API is
     * from a authorized and authenticated source.
     *
     * @param serviceKey The service key
     * @param authToken The authorization token generated after login
     * @return TRUE for acceptance and FALSE for denied.
     */
    public boolean isAuthTokenValid(String serviceKey, String authToken) {
        if (isServiceKeyValid(serviceKey)) {
            String usernameMatch1 = serviceKeysStorage.get(serviceKey);

            if (authorizationTokensStorage.containsKey(authToken)) {
                String usernameMatch2 = authorizationTokensStorage.get(authToken);

                if (usernameMatch1.equals(usernameMatch2)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * This method checks is the service key is valid
     *
     * @param serviceKey
     * @return TRUE if service key matches the pre-generated ones in service key
     * storage. FALSE for otherwise.
     */
    public boolean isServiceKeyValid(String serviceKey) {
        return serviceKeysStorage.containsKey(serviceKey);
    }

    public void logout(String serviceKey, String authToken) throws GeneralSecurityException {
        if (serviceKeysStorage.containsKey(serviceKey)) {
            String usernameMatch1 = serviceKeysStorage.get(serviceKey);

            if (authorizationTokensStorage.containsKey(authToken)) {
                String usernameMatch2 = authorizationTokensStorage.get(authToken);

                if (usernameMatch1.equals(usernameMatch2)) {

                    /**
                     * When a client logs out, the authentication token will be
                     * remove and will be made invalid.
                     */
                    authorizationTokensStorage.remove(authToken);
                    return;
                }
            }
        }

        throw new GeneralSecurityException("Invalid service key and authorization token match.");
    }

    public EntityManager getEm() {
        return em;
    }

    public void setEm(EntityManager em) {
        this.em = em;
    }
}
